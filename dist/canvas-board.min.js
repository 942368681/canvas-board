/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(2);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(4)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(3)(false);
// Module
exports.push([module.i, "/* drawingboard.js v0.4.6 - https://github.com/Leimi/drawingboard.js\r\n* Copyright (c) 2015 Emmanuel Pelletier\r\n* Licensed MIT */\r\n\r\n.drawing-board,\r\n.drawing-board * {\r\n    -webkit-box-sizing: content-box;\r\n    -moz-box-sizing: content-box;\r\n    box-sizing: content-box\r\n}\r\n\r\n.drawing-board-controls-hidden,\r\n.drawing-board-utils-hidden {\r\n    display: none !important\r\n}\r\n\r\n.drawing-board {\r\n    position: relative;\r\n    display: block\r\n}\r\n\r\n.drawing-board-canvas-wrapper {\r\n    position: relative;\r\n    margin: 0;\r\n    border: 1px solid #ddd\r\n}\r\n\r\n.drawing-board-canvas {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: auto;\r\n    cursor: crosshair;\r\n    z-index: 20\r\n}\r\n\r\n.drawing-board-cursor {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    pointer-events: none;\r\n    border-radius: 50%;\r\n    background: #ccc;\r\n    background: rgba(0, 0, 0, .2);\r\n    z-index: 30\r\n}\r\n\r\n.drawing-board-control-colors-rainbows,\r\n.drawing-board-control-size .drawing-board-control-inner,\r\n.drawing-board-control-size-dropdown,\r\n.drawing-board-control>button {\r\n    -webkit-box-sizing: border-box;\r\n    -moz-box-sizing: border-box;\r\n    box-sizing: border-box;\r\n    overflow: hidden;\r\n    background-color: #eee;\r\n    padding: 2px 4px;\r\n    border: 1px solid #ccc;\r\n    box-shadow: 0 1px 3px -2px #121212, inset 0 2px 5px 0 rgba(255, 255, 255, .3);\r\n    -webkit-box-shadow: 0 1px 3px -2px #121212, inset 0 2px 5px 0 rgba(255, 255, 255, .3);\r\n    height: 28px\r\n}\r\n\r\n.drawing-board-control>button {\r\n    cursor: pointer;\r\n    min-width: 28px;\r\n    line-height: 14px\r\n}\r\n\r\n.drawing-board-control>button:focus,\r\n.drawing-board-control>button:hover {\r\n    background-color: #ddd\r\n}\r\n\r\n.drawing-board-control>button.active,\r\n.drawing-board-control>button:active {\r\n    box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, .2);\r\n    -webkit-box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, .2);\r\n    background-color: #ddd\r\n}\r\n\r\n.drawing-board-control>button[disabled] {\r\n    color: gray\r\n}\r\n\r\n.drawing-board-control>button[disabled].active,\r\n.drawing-board-control>button[disabled]:active,\r\n.drawing-board-control>button[disabled]:focus,\r\n.drawing-board-control>button[disabled]:hover {\r\n    background-color: #eee;\r\n    box-shadow: 0 1px 3px -2px #121212, inset 0 2px 5px 0 rgba(255, 255, 255, .3);\r\n    -webkit-box-shadow: 0 1px 3px -2px #121212, inset 0 2px 5px 0 rgba(255, 255, 255, .3);\r\n    cursor: default\r\n}\r\n\r\n.drawing-board-controls {\r\n    margin: 0 auto;\r\n    text-align: center;\r\n    font-size: 0;\r\n    display: table;\r\n    border-spacing: 9.33px 0;\r\n    position: relative;\r\n    min-height: 28px\r\n}\r\n\r\n.drawing-board-controls[data-align=left] {\r\n    margin: 0;\r\n    left: -9.33px\r\n}\r\n\r\n.drawing-board-controls[data-align=right] {\r\n    margin: 0 0 0 auto;\r\n    right: -9.33px\r\n}\r\n\r\n.drawing-board-canvas-wrapper+.drawing-board-controls,\r\n.drawing-board-controls+.drawing-board-canvas-wrapper {\r\n    margin-top: 5px\r\n}\r\n\r\n.drawing-board-controls-hidden {\r\n    height: 0;\r\n    min-height: 0;\r\n    padding: 0;\r\n    margin: 0;\r\n    border: 0\r\n}\r\n\r\n.drawing-board-control {\r\n    display: table-cell;\r\n    border-collapse: separate;\r\n    vertical-align: middle;\r\n    font-size: 16px;\r\n    height: 100%\r\n}\r\n\r\n.drawing-board-control-inner {\r\n    position: relative;\r\n    height: 100%;\r\n    -webkit-box-sizing: border-box;\r\n    -moz-box-sizing: border-box;\r\n    box-sizing: border-box\r\n}\r\n\r\n.drawing-board-control>button {\r\n    margin: 0;\r\n    vertical-align: middle\r\n}\r\n\r\n.drawing-board-control-colors {\r\n    font-size: 0;\r\n    line-height: 0\r\n}\r\n\r\n.drawing-board-control-colors-current {\r\n    border: 1px solid #ccc;\r\n    cursor: pointer;\r\n    display: inline-block;\r\n    width: 26px;\r\n    height: 26px\r\n}\r\n\r\n.drawing-board-control-colors-rainbows {\r\n    display: inline-block;\r\n    position: absolute;\r\n    left: 0;\r\n    top: 33px;\r\n    margin-left: 0;\r\n    z-index: 100;\r\n    width: 250px;\r\n    height: auto;\r\n    padding: 4px\r\n}\r\n\r\n.drawing-board-control-colors-rainbow {\r\n    height: 18px\r\n}\r\n\r\n.drawing-board-control-colors-picker:first-child {\r\n    margin-right: 5px\r\n}\r\n\r\n.drawing-board-control-colors-picker {\r\n    display: inline-block;\r\n    width: 18px;\r\n    height: 18px;\r\n    cursor: pointer\r\n}\r\n\r\n.drawing-board-control-colors-picker[data-color=\"rgba(255, 255, 255, 1)\"] {\r\n    width: 16px;\r\n    height: 17px;\r\n    border: 1px solid #ccc;\r\n    border-bottom: none\r\n}\r\n\r\n.drawing-board-control-colors-picker:hover {\r\n    width: 16px;\r\n    height: 16px;\r\n    border: 1px solid #555\r\n}\r\n\r\n.drawing-board-control-drawingmode>button {\r\n    margin-right: 2px\r\n}\r\n\r\n.drawing-board-control-drawingmode>button:last-child {\r\n    margin-right: 0\r\n}\r\n\r\n.drawing-board-control-drawingmode-pencil-button {\r\n    overflow: hidden;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAe9JREFUeNpiZAACVlFRBhYREQZcQPnbNwa3N28YlL5+ZfgLFfvPwGD9m4FhIgsDHuAO0gTUDNKIBvyBmqt/MTDMY8Gl0f31azD7L6oUIxCnAzWmAPHBfwwM01AMUAV6JfPQIVwOYgVqqPnFyOjz6///O38YGKpAgmAD1OXlGdTk5PD5hgeouZudj8/uy9evP/78/dsFFPsJNiAoKIiBABAHap4oLi9v8fTNm48//v7NBwbgWZgkE7rqt8DY+A8JZRBW+cfIuEDT0NDlzadP3z98/doPFDuCrB7TAGFhBqCNIGwM9OcKUzs7+xdv3355+f79VqDYAiTDwZgJh7ONgYpnOvn4GL949erT7UePdgL5JVCD4fgBLBBxaX74+PG789evnwby0/8jKXgExIeB+CG6Af///1e9Ki9vFSAkZPzoyZPPJy9evA9MB77/sWiEARZkzV+/fvXYtGnTpG3btj28EBT0BqjZ5D8OjXCwPksUhA1Wpggf/PHjx/9169Y9EBERaUlgZmaIAcrLE4rk5sIqBqDmlefnRPzfWGX5EaSZm5ubgRloADGA5QZ3RgK7gESY4PMNn9ZtObPpzZvfU4DiYkiB/RcHG+S7fyxAMH/lFU2GOZd2bLx18/cEUMoD4j9I+DcS/RtJHGTYf4AAAwAxaOMYHjxKFwAAAABJRU5ErkJggg==);\r\n    background-position: 50% 50%;\r\n    background-repeat: no-repeat\r\n}\r\n\r\n.drawing-board-control-drawingmode-pencil-button:before {\r\n    content: \"\";\r\n    display: block;\r\n    width: 0;\r\n    height: 100%\r\n}\r\n\r\n.drawing-board-control-drawingmode-eraser-button {\r\n    overflow: hidden;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAkpJREFUeNp0kk+IElEcx39vFBc9+OfQRTAwzFt4CaYOKStj6MoeculStzoIQSB4kCVckmDx4iGCXWYJIqjoVOzO1l4qT1F7WfBWHvxzDPyTB3XUmXn93suRybUffHmP997n9/cRsFgwGARJkiAcDsPlwgEIeEZQAhCRAkgAlOD6SQP4rgMFDWVnYCAQgFgsBqFQCBwOByzZNQOotPHx1RNCCCipu6bfb+zSnslkeOQVILPrBkAirbws9btdTEWAzZPXpfepOzaeGMBXwe/3w3+MwTc3Dl+UeghTiskbBvR6Pbh18mZHB0jjmxvCKhIfR37s3r+Sevf8ca/T4TBF2HTSODuDxP7uNjrZFFbBk8lEzOVyspa4ykGYw2zfbTb/7ilvok1YhlVVFfP5vDydTkHXdXDdlhZOOnPY4/HA0YPtp3h6LFjh8XgsFgoFGTPgsKm1zDr8ajTQh8Fh5eGjZzjGI8yjKlgjF4tFGdd/YKYmRja24hw+zu3sYe2HiH3hYzQjl8tleTQanWtou93G6Qngdrth6+1+9h6hTULJZ/PeziJXKhV5OByeg1ut1gJOp9NZTdNOcQ419ot+ggp1qoLdBFmqVmNpm3A8Huewy+Wq1RH8QH9zmBlJJpMRdCIqiiIPBgN+2MCGsW/r8/kgGo1m0fmpzWarseayHlmNeL1eFiWC0cRqtSr3+/3FpSiKHMZtjU1glbFyfKgLTqfzEka9OJvNeDnzz1JnCaFmqOl8ZdJY1SiDOXCiXKg1NtG5DIt0y6ov3dE/AgwAENFWYYLj4mYAAAAASUVORK5CYII=);\r\n    background-position: 50% 50%;\r\n    background-repeat: no-repeat\r\n}\r\n\r\n.drawing-board-control-drawingmode-eraser-button:before {\r\n    content: \"\";\r\n    display: block;\r\n    width: 0;\r\n    height: 100%\r\n}\r\n\r\n.drawing-board-control-drawingmode-filler-button {\r\n    overflow: hidden;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAnNJREFUeNp0k0trE1EUx89MJpNJooYYXBgDNtCKdRPwlbqoCKUtaNVNA0Uo7UbMxoVPEARTXEi+QWfnwn6DEAlEkrSLttTGRiULEQlJ8yChmbzI++E50yTUJA78uMy953/u/557LmOz2WDEZ2m1WrckSRJSqdR2tVrdHQyYebwHtVoNuFHqTqczhQnWKaBYLDoKhcIuzgHDMKBSqeD20qd+LNdsNocSoFhRr9ctpVLJigl4xIIJQizLAmG4cAPa7bYcy9Iug5TL5UYikbD6/X7Rbre/IUcYe3WUW5ZsnQQzW9LpNOPz+UQc5aBM5mgdh7vI9FCCAesW2tnr9YqZTAby+bw8f3AQRP6853n+Ph5hemSCntjj8YjZbFYWx2IxeS2RSEMwuA87O79eqdXquVolK+GxnP0EPbHb7RZJSGABIR6PA11zJHKIR2MhHA5DIPDj7eH3j95KpfK60Wg8Yntil8slkqgnpioLghacTidoNDpEC3q9HnheCc3s1jZeLcW943pirPw/4lKpBkqlDubnl/riycnLsLy88EKj0fhzuRyZv8RFo1E6wpBYkiqy7Z54YmIcVlYeyOKC4mYwJ0nHRaQuM5vNT6hB/iceG7sIq6sPnwmC4MerDkby40AOCCoiddie1Wp92W7zQ2KTyQSLizNP8T0EsPLBbxEDnCj0GkM2qIEwyZRCobizsfH5A1ZXFhuN52F29vpz3HkL574mk8lj24Y5wsHkvjjoX0BOIWc5jruHzbK2ufmzEwpFO3jnDhQv4JoROYdoERVyGjEgZ8iBDlF3FzXo4go6utZ9lftY4N/dXisjR0i1G0ublv8KMAA0ZoUlicxrhwAAAABJRU5ErkJggg==);\r\n    background-position: 50% 50%;\r\n    background-repeat: no-repeat\r\n}\r\n\r\n.drawing-board-control-drawingmode-filler-button:before {\r\n    content: \"\";\r\n    display: block;\r\n    width: 0;\r\n    height: 100%\r\n}\r\n\r\n.drawing-board-control-navigation>button {\r\n    font-family: Helvetica, Arial, sans-serif;\r\n    font-size: 14px;\r\n    font-weight: 700;\r\n    margin-right: 2px\r\n}\r\n\r\n.drawing-board-control-navigation>button:last-child {\r\n    margin-right: 0\r\n}\r\n\r\n.drawing-board-control-size[data-drawing-board-type=range] .drawing-board-control-inner {\r\n    width: 75px\r\n}\r\n\r\n.drawing-board-control-size[data-drawing-board-type=dropdown] .drawing-board-control-inner {\r\n    overflow: visible\r\n}\r\n\r\n.drawing-board-control-size-range-input {\r\n    position: relative;\r\n    width: 100%;\r\n    z-index: 100;\r\n    margin: 0;\r\n    padding: 0;\r\n    border: 0\r\n}\r\n\r\n.drawing-board-control-size-dropdown span,\r\n.drawing-board-control-size-dropdown-current span,\r\n.drawing-board-control-size-range-current {\r\n    display: block;\r\n    background: #333;\r\n    opacity: .8\r\n}\r\n\r\n.drawing-board-control-size-range-current {\r\n    display: inline-block;\r\n    opacity: .15;\r\n    position: absolute;\r\n    pointer-events: none;\r\n    left: 50%;\r\n    top: 50%;\r\n    z-index: 50\r\n}\r\n\r\n.drawing-board-control-size-dropdown-current {\r\n    display: block;\r\n    height: 100%;\r\n    width: 40px;\r\n    overflow: hidden;\r\n    position: relative\r\n}\r\n\r\n.drawing-board-control-size-dropdown-current span {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%\r\n}\r\n\r\n.drawing-board-control-size-dropdown {\r\n    position: absolute;\r\n    left: -6px;\r\n    top: 33px;\r\n    height: auto;\r\n    list-style-type: none;\r\n    margin: 0;\r\n    padding: 0;\r\n    z-index: 100\r\n}\r\n\r\n.drawing-board-control-size-dropdown li {\r\n    display: block;\r\n    padding: 4px;\r\n    margin: 3px 0;\r\n    min-height: 16px\r\n}\r\n\r\n.drawing-board-control-size-dropdown li:hover {\r\n    background: #ccc\r\n}\r\n\r\n.drawing-board-control-size-dropdown span {\r\n    margin: 0 auto\r\n}\r\n\r\n.drawing-board-control-download-button {\r\n    overflow: hidden;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAoBJREFUeNqMkr9PU1EUx7/vR1tQ3yu10hAmTawtBSYSy2YccFOcnDQm/gewOLnj5GYMg4sdXFxkMca4OBAwdUBe/ZkIGFp+9tHXvh/3/fTcAm01aLzJybnn3nM+95tzrnDl6Tb+sibuTmWUWj3C6/Juk+LySUmyvt0FCKKA02ryOCy6LBiu15ngMbZ5DDCNBqIw6gKM+n4nECUJru3glKry8CpjQaHVYmC2rVH82DIMMMdGGARdwJ+SPNdFS9chx+MXDNMp/NzagWNatk/nQU/hiYAoih6FYTBCBs9zUXMCbAhx2OYOv351lPOJ3EwH4LteL6Dcp/Rfu3FrstDyIizt+agpaYxNDU0M9gl4v7Ck+TYrCYLQqZHUyTtdQBiutPSGUflczSXHs5lVKwZdSOBMvwztxVvN0RtzsiyXBFHsAvL5PBSnCpXV2getILFiE2SjspYbuZzPiDSZ2vOXmlvX5yQqTmMfg9ZXqtls1wnT09OHEyAq0aFLg/gSXsSWq9wWk+p9PrCoYTwcijdLOfE7UsEufN9HGIYnT4EnTGIXe1KqtNNIvuNnGamxfi7SgQD/nIJCTbzOPQ/SQh1pud7T4M6W/8qFIw/5WAr5m7Ozsw9UVc069Fls2yJzSC5/lnc9RhaHZVnfSqUnEgXP2oBqtYqBgYG2+mKxmOVADnAcB4yxHgD1RzehKKns/LyV4gUHBweQy+UyRkdH6UKJ6fQDFxcXoWkaXJeRuTgUGCdLQJ9bx72lGZimGWs2m+083oN+2iiFQiGxvLy8RrDzudyltgrG3N8U2G8CrPz4sGYYRqJSqWR4H/jNWbJhUjAWi8XG8R/L87yPpGCVttVfAgwAVpZR+8tZC08AAAAASUVORK5CYII=);\r\n    background-position: 50% 50%;\r\n    background-repeat: no-repeat\r\n}\r\n\r\n.drawing-board-control-download-button:before {\r\n    content: \"\";\r\n    display: block;\r\n    width: 0;\r\n    height: 100%\r\n}", ""]);



/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(5);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(0);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// CONCATENATED MODULE: ./lib/drawingboard/index.js


/* drawingboard.js v0.4.6 - https://github.com/Leimi/drawingboard.js
* Copyright (c) 2015 Emmanuel Pelletier
* Licensed MIT */
(function () {
  'use strict';
  /**
   * SimpleUndo is a very basic javascript undo/redo stack for managing histories of basically anything.
   * 
   * options are: {
   * 	* `provider` : required. a function to call on `save`, which should provide the current state of the historized object through the given "done" callback
   * 	* `maxLength` : the maximum number of items in history
   * 	* `opUpdate` : a function to call to notify of changes in history. Will be called on `save`, `undo`, `redo` and `clear`
   * }
   * 
   */

  var SimpleUndo = function SimpleUndo(options) {
    var settings = options ? options : {};
    var defaultOptions = {
      provider: function provider() {
        throw new Error("No provider!");
      },
      maxLength: 30,
      onUpdate: function onUpdate() {}
    };
    this.provider = typeof settings.provider != 'undefined' ? settings.provider : defaultOptions.provider;
    this.maxLength = typeof settings.maxLength != 'undefined' ? settings.maxLength : defaultOptions.maxLength;
    this.onUpdate = typeof settings.onUpdate != 'undefined' ? settings.onUpdate : defaultOptions.onUpdate;
    this.initialItem = null;
    this.clear();
  };

  function truncate(stack, limit) {
    while (stack.length > limit) {
      stack.shift();
    }
  }

  SimpleUndo.prototype.initialize = function (initialItem) {
    this.stack[0] = initialItem;
    this.initialItem = initialItem;
  };

  SimpleUndo.prototype.clear = function () {
    this.stack = [this.initialItem];
    this.position = 0;
    this.onUpdate();
  };

  SimpleUndo.prototype.save = function () {
    this.provider(function (current) {
      truncate(this.stack, this.maxLength);
      this.position = Math.min(this.position, this.stack.length - 1);
      this.stack = this.stack.slice(0, this.position + 1);
      this.stack.push(current);
      this.position++;
      this.onUpdate();
    }.bind(this));
  };

  SimpleUndo.prototype.undo = function (callback) {
    if (this.canUndo()) {
      var item = this.stack[--this.position];
      this.onUpdate();

      if (callback) {
        callback(item);
      }
    }
  };

  SimpleUndo.prototype.redo = function (callback) {
    if (this.canRedo()) {
      var item = this.stack[++this.position];
      this.onUpdate();

      if (callback) {
        callback(item);
      }
    }
  };

  SimpleUndo.prototype.canUndo = function () {
    return this.position > 0;
  };

  SimpleUndo.prototype.canRedo = function () {
    return this.position < this.count();
  };

  SimpleUndo.prototype.count = function () {
    return this.stack.length - 1; // -1 because of initial item
  }; //exports
  // node module
  // if (typeof module != 'undefined') {
  //     module.exports = SimpleUndo;
  // }
  // browser global


  if (typeof window != 'undefined') {
    window.SimpleUndo = SimpleUndo;
  }
})();

window.DrawingBoard = typeof DrawingBoard !== "undefined" ? DrawingBoard : {};
DrawingBoard.Utils = {};
/*!
* Tim (lite)
*   github.com/premasagar/tim
*/

/*
  A tiny, secure JavaScript micro-templating script.
*/

DrawingBoard.Utils.tpl = function () {
  "use strict";

  var start = "{{",
      end = "}}",
      path = "[a-z0-9_][\\.a-z0-9_]*",
      // e.g. config.person.name
  pattern = new RegExp(start + "\\s*(" + path + ")\\s*" + end, "gi"),
      undef;
  return function (template, data) {
    // Merge data into the template string
    return template.replace(pattern, function (tag, token) {
      var path = token.split("."),
          len = path.length,
          lookup = data,
          i = 0;

      for (; i < len; i++) {
        lookup = lookup[path[i]]; // Property not found

        if (lookup === undef) {
          throw "tim: '" + path[i] + "' not found in " + tag;
        } // Return the required value


        if (i === len - 1) {
          return lookup;
        }
      }
    });
  };
}();
/**
 * https://github.com/jeromeetienne/microevent.js
 * MicroEvent - to make any js object an event emitter (server or browser)
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediatly, no mistery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/


DrawingBoard.Utils.MicroEvent = function () {};

DrawingBoard.Utils.MicroEvent.prototype = {
  bind: function bind(event, fct) {
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];

    this._events[event].push(fct);
  },
  unbind: function unbind(event, fct) {
    this._events = this._events || {};
    if (event in this._events === false) return;

    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  trigger: function trigger(event
  /* , args... */
  ) {
    this._events = this._events || {};
    if (event in this._events === false) return;

    for (var i = 0; i < this._events[event].length; i++) {
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
}; //I know.

DrawingBoard.Utils._boxBorderSize = function ($el, withPadding, withMargin, direction) {
  withPadding = !!withPadding || true;
  withMargin = !!withMargin || false;
  var width = 0,
      props;

  if (direction == "width") {
    props = ['border-left-width', 'border-right-width'];
    if (withPadding) props.push('padding-left', 'padding-right');
    if (withMargin) props.push('margin-left', 'margin-right');
  } else {
    props = ['border-top-width', 'border-bottom-width'];
    if (withPadding) props.push('padding-top', 'padding-bottom');
    if (withMargin) props.push('margin-top', 'margin-bottom');
  }

  for (var i = props.length - 1; i >= 0; i--) {
    width += parseInt($el.css(props[i]).replace('px', ''), 10);
  }

  return width;
};

DrawingBoard.Utils.boxBorderWidth = function ($el, withPadding, withMargin) {
  return DrawingBoard.Utils._boxBorderSize($el, withPadding, withMargin, 'width');
};

DrawingBoard.Utils.boxBorderHeight = function ($el, withPadding, withMargin) {
  return DrawingBoard.Utils._boxBorderSize($el, withPadding, withMargin, 'height');
};

DrawingBoard.Utils.isColor = function (string) {
  if (!string || !string.length) return false;
  return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(string) || $.inArray(string.substring(0, 3), ['rgb', 'hsl']) !== -1;
};
/**
 * Packs an RGB color into a single integer.
 */


DrawingBoard.Utils.RGBToInt = function (r, g, b) {
  var c = 0;
  c |= (r & 255) << 16;
  c |= (g & 255) << 8;
  c |= b & 255;
  return c;
};
/**
 * Returns informations on the pixel located at (x,y).
 */


DrawingBoard.Utils.pixelAt = function (image, x, y) {
  var i = (y * image.width + x) * 4;
  var c = DrawingBoard.Utils.RGBToInt(image.data[i], image.data[i + 1], image.data[i + 2]);
  return [i, // INDEX
  x, // X
  y, // Y
  c // COLOR
  ];
};
/**
 * Compares two colors with the given tolerance (between 0 and 255).
 */


DrawingBoard.Utils.compareColors = function (a, b, tolerance) {
  if (tolerance === 0) {
    return a === b;
  }

  var ra = a >> 16 & 255,
      rb = b >> 16 & 255,
      ga = a >> 8 & 255,
      gb = b >> 8 & 255,
      ba = a & 255,
      bb = b & 255;
  return Math.abs(ra - rb) <= tolerance && Math.abs(ga - gb) <= tolerance && Math.abs(ba - bb) <= tolerance;
};

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }
})();

window.DrawingBoard = typeof DrawingBoard !== "undefined" ? DrawingBoard : {};
/**
 * pass the id of the html element to put the drawing board into
 * and some options : {
 *	controls: array of controls to initialize with the drawingboard. 'Colors', 'Size', and 'Navigation' by default
 *		instead of simple strings, you can pass an object to define a control opts
 *		ie ['Color', { Navigation: { reset: false }}]
 *	controlsPosition: "top left" by default. Define where to put the controls: at the "top" or "bottom" of the canvas, aligned to "left"/"right"/"center"
 *	background: background of the drawing board. Give a hex color or an image url "#ffffff" (white) by default
 *	color: pencil color ("#000000" by default)
 *	size: pencil size (3 by default)
 *	webStorage: 'session', 'local' or false ('session' by default). store the current drawing in session or local storage and restore it when you come back
 *	droppable: true or false (false by default). If true, dropping an image on the canvas will include it and allow you to draw on it,
 *	errorMessage: html string to put in the board's element on browsers that don't support canvas.
 *	stretchImg: default behavior of image setting on the canvas: set to the canvas width/height or not? false by default
 * }
 */

DrawingBoard.Board = function (id, opts) {
  this.opts = this.mergeOptions(opts);
  this.ev = new DrawingBoard.Utils.MicroEvent();
  this.id = id;
  this.$el = $(document.getElementById(id));
  if (!this.$el.length) return false;
  var tpl = '<div class="drawing-board-canvas-wrapper"></canvas><canvas class="drawing-board-canvas"></canvas><div class="drawing-board-cursor drawing-board-utils-hidden"></div></div>';
  if (this.opts.controlsPosition.indexOf("bottom") > -1) tpl += '<div class="drawing-board-controls"></div>';else tpl = '<div class="drawing-board-controls"></div>' + tpl;
  this.$el.addClass('drawing-board').append(tpl);
  this.dom = {
    $canvasWrapper: this.$el.find('.drawing-board-canvas-wrapper'),
    $canvas: this.$el.find('.drawing-board-canvas'),
    $cursor: this.$el.find('.drawing-board-cursor'),
    $controls: this.$el.find('.drawing-board-controls')
  };
  $.each(['left', 'right', 'center'], $.proxy(function (n, val) {
    if (this.opts.controlsPosition.indexOf(val) > -1) {
      this.dom.$controls.attr('data-align', val);
      return false;
    }
  }, this));
  this.canvas = this.dom.$canvas.get(0);
  this.ctx = this.canvas && this.canvas.getContext && this.canvas.getContext('2d') ? this.canvas.getContext('2d') : null;
  this.color = this.opts.color;

  if (!this.ctx) {
    if (this.opts.errorMessage) this.$el.html(this.opts.errorMessage);
    return false;
  }

  this.storage = this._getStorage();
  this.initHistory(); //init default board values before controls are added (mostly pencil color and size)

  this.reset({
    webStorage: false,
    history: false,
    background: false
  }); //init controls (they will need the default board values to work like pencil color and size)

  this.initControls(); //set board's size after the controls div is added

  this.resize(); //reset the board to take all resized space

  this.reset({
    webStorage: false,
    history: false,
    background: true
  });
  this.restoreWebStorage();
  this.initDropEvents();
  this.initDrawEvents();
};

DrawingBoard.Board.defaultOpts = {
  controls: ['Color', 'DrawingMode', 'Size', 'Navigation'],
  controlsPosition: "top left",
  color: "#000000",
  size: 1,
  background: "#fff",
  eraserColor: "background",
  fillTolerance: 100,
  fillHack: true,
  //try to prevent issues with anti-aliasing with a little hack by default
  webStorage: 'session',
  droppable: false,
  enlargeYourContainer: false,
  errorMessage: "<p>It seems you use an obsolete browser. <a href=\"http://browsehappy.com/\" target=\"_blank\">Update it</a> to start drawing.</p>",
  stretchImg: false //when setting the canvas img, strech the image at the whole canvas size when this opt is true

};
DrawingBoard.Board.prototype = {
  mergeOptions: function mergeOptions(opts) {
    opts = $.extend({}, DrawingBoard.Board.defaultOpts, opts);
    if (!opts.background && opts.eraserColor === "background") opts.eraserColor = "transparent";
    return opts;
  },

  /**
   * Canvas reset/resize methods: put back the canvas to its default values
   *
   * depending on options, can set color, size, background back to default values
   * and store the reseted canvas in webstorage and history queue
   *
   * resize values depend on the `enlargeYourContainer` option
   */
  reset: function reset(opts) {
    opts = $.extend({
      color: this.opts.color,
      size: this.opts.size,
      webStorage: true,
      history: true,
      background: false
    }, opts);
    this.setMode('pencil');

    if (opts.background) {
      this.resetBackground(this.opts.background, $.proxy(function () {
        if (opts.history) this.saveHistory();
      }, this));
    }

    if (opts.color) this.setColor(opts.color);
    if (opts.size) this.ctx.lineWidth = opts.size;
    this.ctx.lineCap = "round";
    this.ctx.lineJoin = "round"; // this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.width);

    if (opts.webStorage) this.saveWebStorage(); // if opts.background we already dealt with the history

    if (opts.history && !opts.background) this.saveHistory();
    this.blankCanvas = this.getImg();
    this.ev.trigger('board:reset', opts);
  },
  resetBackground: function resetBackground(background, callback) {
    background = background || this.opts.background;
    var bgIsColor = DrawingBoard.Utils.isColor(background);
    var prevMode = this.getMode();
    this.setMode('pencil');
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

    if (bgIsColor) {
      this.ctx.fillStyle = background;
      this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      this.history.initialize(this.getImg());
      if (callback) callback();
    } else if (background) this.setImg(background, {
      callback: $.proxy(function () {
        this.history.initialize(this.getImg());
        if (callback) callback();
      }, this)
    });

    this.setMode(prevMode);
  },
  resize: function resize() {
    this.dom.$controls.toggleClass('drawing-board-controls-hidden', !this.controls || !this.controls.length);
    var canvasWidth, canvasHeight;
    var widths = [this.$el.width(), DrawingBoard.Utils.boxBorderWidth(this.$el), DrawingBoard.Utils.boxBorderWidth(this.dom.$canvasWrapper, true, true)];
    var heights = [this.$el.height(), DrawingBoard.Utils.boxBorderHeight(this.$el), this.dom.$controls.height(), DrawingBoard.Utils.boxBorderHeight(this.dom.$controls, false, true), DrawingBoard.Utils.boxBorderHeight(this.dom.$canvasWrapper, true, true)];
    var that = this;

    var sum = function sum(values, multiplier) {
      //make the sum of all array values
      multiplier = multiplier || 1;
      var res = values[0];

      for (var i = 1; i < values.length; i++) {
        res = res + values[i] * multiplier;
      }

      return res;
    };

    var sub = function sub(values) {
      return sum(values, -1);
    }; //substract all array values from the first one


    if (this.opts.enlargeYourContainer) {
      canvasWidth = this.$el.width();
      canvasHeight = this.$el.height();
      this.$el.width(sum(widths));
      this.$el.height(sum(heights));
    } else {
      canvasWidth = sub(widths);
      canvasHeight = sub(heights);
    }

    this.dom.$canvasWrapper.css('width', canvasWidth + 'px');
    this.dom.$canvasWrapper.css('height', canvasHeight + 'px');
    this.dom.$canvas.css('width', canvasWidth + 'px');
    this.dom.$canvas.css('height', canvasHeight + 'px');
    this.canvas.width = canvasWidth;
    this.canvas.height = canvasHeight;
  },

  /**
   * Controls:
   * the drawing board can has various UI elements to control it.
   * one control is represented by a class in the namespace DrawingBoard.Control
   * it must have a $el property (jQuery object), representing the html element to append on the drawing board at initialization.
   *
   */
  initControls: function initControls() {
    this.controls = [];
    if (!this.opts.controls.length || !DrawingBoard.Control) return false;

    for (var i = 0; i < this.opts.controls.length; i++) {
      var c = null;
      if (typeof this.opts.controls[i] == "string") c = new window['DrawingBoard']['Control'][this.opts.controls[i]](this);else if (typeof_default()(this.opts.controls[i]) == "object") {
        for (var controlName in this.opts.controls[i]) {
          break;
        }

        c = new window['DrawingBoard']['Control'][controlName](this, this.opts.controls[i][controlName]);
      }

      if (c) {
        this.addControl(c);
      }
    }
  },
  //add a new control or an existing one at the position you want in the UI
  //to add a totally new control, you can pass a string with the js class as 1st parameter and control options as 2nd ie "addControl('Navigation', { reset: false }"
  //the last parameter (2nd or 3rd depending on the situation) is always the position you want to place the control at
  addControl: function addControl(control, optsOrPos, pos) {
    if (typeof control !== "string" && (typeof_default()(control) !== "object" || !control instanceof DrawingBoard.Control)) return false;
    var opts = typeof_default()(optsOrPos) == "object" ? optsOrPos : {};
    pos = pos ? pos * 1 : typeof optsOrPos == "number" ? optsOrPos : null;
    if (typeof control == "string") control = new window['DrawingBoard']['Control'][control](this, opts);
    if (pos) this.dom.$controls.children().eq(pos).before(control.$el);else this.dom.$controls.append(control.$el);
    if (!this.controls) this.controls = [];
    this.controls.push(control);
    this.dom.$controls.removeClass('drawing-board-controls-hidden');
  },

  /**
   * History methods: undo and redo drawed lines
   */
  initHistory: function initHistory() {
    this.history = new SimpleUndo({
      maxLength: 30,
      provider: $.proxy(function (done) {
        done(this.getImg());
      }, this),
      onUpdate: $.proxy(function () {
        this.ev.trigger('historyNavigation');
      }, this)
    });
  },
  saveHistory: function saveHistory() {
    this.history.save();
  },
  restoreHistory: function restoreHistory(image) {
    this.setImg(image, {
      callback: $.proxy(function () {
        this.saveWebStorage();
      }, this)
    });
  },
  goBackInHistory: function goBackInHistory() {
    this.history.undo($.proxy(this.restoreHistory, this));
  },
  goForthInHistory: function goForthInHistory() {
    this.history.redo($.proxy(this.restoreHistory, this));
  },

  /**
   * Image methods: you can directly put an image on the canvas, get it in base64 data url or start a download
   */
  setImg: function setImg(src, opts) {
    opts = $.extend({
      stretch: this.opts.stretchImg,
      callback: null
    }, opts);
    var ctx = this.ctx;
    var img = new Image();
    var oldGCO = ctx.globalCompositeOperation;

    img.onload = function () {
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      if (opts.stretch) {
        ctx.drawImage(img, 0, 0, ctx.canvas.width, ctx.canvas.height);
      } else {
        var x,
            y = 0;
        var w = img.width;
        var h = img.height;
        var rate = img.width / img.height - ctx.canvas.width / ctx.canvas.height; // rate 0

        if (rate > 0) {
          // ,
          if (img.width > ctx.canvas.width) {
            w = ctx.canvas.width;
            h = img.height / (img.width / ctx.canvas.width);
          }
        } else {
          if (img.height > ctx.canvas.height) {
            h = ctx.canvas.height;
            w = img.width / (img.height / ctx.canvas.height);
          }
        }

        x = (ctx.canvas.width - w) / 2;
        y = (ctx.canvas.height - h) / 2;
        ctx.drawImage(img, x, y, w, h);
      }

      ctx.globalCompositeOperation = oldGCO;

      if (opts.callback) {
        opts.callback();
      }
    };

    img.src = src;
  },
  getImg: function getImg() {
    return this.canvas.toDataURL("image/png");
  },
  downloadImg: function downloadImg() {
    var img = this.getImg();
    img = img.replace("image/png", "image/octet-stream");
    window.location.href = img;
  },

  /**
   * WebStorage handling : save and restore to local or session storage
   */
  saveWebStorage: function saveWebStorage() {
    if (window[this.storage]) {
      window[this.storage].setItem('drawing-board-' + this.id, this.getImg());
      this.ev.trigger('board:save' + this.storage.charAt(0).toUpperCase() + this.storage.slice(1), this.getImg());
    }
  },
  restoreWebStorage: function restoreWebStorage() {
    if (window[this.storage] && window[this.storage].getItem('drawing-board-' + this.id) !== null) {
      this.setImg(window[this.storage].getItem('drawing-board-' + this.id));
      this.ev.trigger('board:restore' + this.storage.charAt(0).toUpperCase() + this.storage.slice(1), window[this.storage].getItem('drawing-board-' + this.id));
    }
  },
  clearWebStorage: function clearWebStorage() {
    if (window[this.storage] && window[this.storage].getItem('drawing-board-' + this.id) !== null) {
      window[this.storage].removeItem('drawing-board-' + this.id);
      this.ev.trigger('board:clear' + this.storage.charAt(0).toUpperCase() + this.storage.slice(1));
    }
  },
  _getStorage: function _getStorage() {
    if (!this.opts.webStorage || !(this.opts.webStorage === 'session' || this.opts.webStorage === 'local')) return false;
    return this.opts.webStorage + 'Storage';
  },

  /**
   * Drop an image on the canvas to draw on it
   */
  initDropEvents: function initDropEvents() {
    if (!this.opts.droppable) return false;
    this.dom.$canvas.on('dragover dragenter drop', function (e) {
      e.stopPropagation();
      e.preventDefault();
    });
    this.dom.$canvas.on('drop', $.proxy(this._onCanvasDrop, this));
  },
  _onCanvasDrop: function _onCanvasDrop(e) {
    e = e.originalEvent ? e.originalEvent : e;
    var files = e.dataTransfer.files;
    if (!files || !files.length || files[0].type.indexOf('image') == -1 || !window.FileReader) return false;
    var fr = new FileReader();
    fr.readAsDataURL(files[0]);
    fr.onload = $.proxy(function (ev) {
      this.setImg(ev.target.result, {
        callback: $.proxy(function () {
          this.saveHistory();
        }, this)
      });
      this.ev.trigger('board:imageDropped', ev.target.result);
      this.ev.trigger('board:userAction');
    }, this);
  },

  /**
   * set and get current drawing mode
   *
   * possible modes are "pencil" (draw normally), "eraser" (draw transparent, like, erase, you know), "filler" (paint can)
   */
  setMode: function setMode(newMode, silent) {
    silent = silent || false;
    newMode = newMode || 'pencil';
    this.ev.unbind('board:startDrawing', $.proxy(this.fill, this));
    if (this.opts.eraserColor === "transparent") this.ctx.globalCompositeOperation = newMode === "eraser" ? "destination-out" : "source-over";else {
      if (newMode === "eraser") {
        if (this.opts.eraserColor === "background" && DrawingBoard.Utils.isColor(this.opts.background)) this.ctx.strokeStyle = this.opts.background;else if (DrawingBoard.Utils.isColor(this.opts.eraserColor)) this.ctx.strokeStyle = this.opts.eraserColor;
      } else if (!this.mode || this.mode === "eraser") {
        this.ctx.strokeStyle = this.color;
      }

      if (newMode === "filler") this.ev.bind('board:startDrawing', $.proxy(this.fill, this));
    }
    this.mode = newMode;
    if (!silent) this.ev.trigger('board:mode', this.mode);
  },
  getMode: function getMode() {
    return this.mode || "pencil";
  },
  setColor: function setColor(color) {
    var that = this;
    color = color || this.color;
    if (!DrawingBoard.Utils.isColor(color)) return false;
    this.color = color;

    if (this.opts.eraserColor !== "transparent" && this.mode === "eraser") {
      var setStrokeStyle = function setStrokeStyle(mode) {
        if (mode !== "eraser") that.strokeStyle = that.color;
        that.ev.unbind('board:mode', setStrokeStyle);
      };

      this.ev.bind('board:mode', setStrokeStyle);
    } else this.ctx.strokeStyle = this.color;
  },

  /**
   * Fills an area with the current stroke color.
   */
  fill: function fill(e) {
    if (this.getImg() === this.blankCanvas) {
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      this.ctx.fillStyle = this.color;
      this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      return;
    }

    var img = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height); // constants identifying pixels components

    var INDEX = 0,
        X = 1,
        Y = 2,
        COLOR = 3; // target color components

    var stroke = this.ctx.strokeStyle;
    var r = parseInt(stroke.substr(1, 2), 16);
    var g = parseInt(stroke.substr(3, 2), 16);
    var b = parseInt(stroke.substr(5, 2), 16); // starting point

    var start = DrawingBoard.Utils.pixelAt(img, parseInt(e.coords.x, 10), parseInt(e.coords.y, 10));
    var startColor = start[COLOR];
    var tolerance = this.opts.fillTolerance;
    var useHack = this.opts.fillHack; //see https://github.com/Leimi/drawingboard.js/pull/38
    // no need to continue if starting and target colors are the same

    if (DrawingBoard.Utils.compareColors(startColor, DrawingBoard.Utils.RGBToInt(r, g, b), tolerance)) return; // pixels to evaluate

    var queue = [start]; // loop vars

    var pixel, x, y;
    var maxX = img.width - 1;
    var maxY = img.height - 1;

    function updatePixelColor(pixel) {
      img.data[pixel[INDEX]] = r;
      img.data[pixel[INDEX] + 1] = g;
      img.data[pixel[INDEX] + 2] = b;
    }

    while (pixel = queue.pop()) {
      if (useHack) updatePixelColor(pixel);

      if (DrawingBoard.Utils.compareColors(pixel[COLOR], startColor, tolerance)) {
        if (!useHack) updatePixelColor(pixel);
        if (pixel[X] > 0) // west
          queue.push(DrawingBoard.Utils.pixelAt(img, pixel[X] - 1, pixel[Y]));
        if (pixel[X] < maxX) // east
          queue.push(DrawingBoard.Utils.pixelAt(img, pixel[X] + 1, pixel[Y]));
        if (pixel[Y] > 0) // north
          queue.push(DrawingBoard.Utils.pixelAt(img, pixel[X], pixel[Y] - 1));
        if (pixel[Y] < maxY) // south
          queue.push(DrawingBoard.Utils.pixelAt(img, pixel[X], pixel[Y] + 1));
      }
    }

    this.ctx.putImageData(img, 0, 0);
  },

  /**
   * Drawing handling, with mouse or touch
   */
  initDrawEvents: function initDrawEvents() {
    this.isDrawing = false;
    this.isMouseHovering = false;
    this.coords = {};
    this.coords.old = this.coords.current = this.coords.oldMid = {
      x: 0,
      y: 0
    };
    this.dom.$canvas.on('mousedown touchstart', $.proxy(function (e) {
      this._onInputStart(e, this._getInputCoords(e));
    }, this));
    this.dom.$canvas.on('mousemove touchmove', $.proxy(function (e) {
      this._onInputMove(e, this._getInputCoords(e));
    }, this));
    this.dom.$canvas.on('mousemove', $.proxy(function (e) {}, this));
    this.dom.$canvas.on('mouseup touchend', $.proxy(function (e) {
      this._onInputStop(e, this._getInputCoords(e));
    }, this));
    this.dom.$canvas.on('mouseover', $.proxy(function (e) {
      this._onMouseOver(e, this._getInputCoords(e));
    }, this));
    this.dom.$canvas.on('mouseout', $.proxy(function (e) {
      this._onMouseOut(e, this._getInputCoords(e));
    }, this));
    $('body').on('mouseup touchend', $.proxy(function (e) {
      this.isDrawing = false;
    }, this));
    if (window.requestAnimationFrame) requestAnimationFrame($.proxy(this.draw, this));
  },
  draw: function draw() {
    //if the pencil size is big (>10), the small crosshair makes a friend: a circle of the size of the pencil
    //todo: have the circle works on every browser - it currently should be added only when CSS pointer-events are supported
    //we assume that if requestAnimationFrame is supported, pointer-events is too, but this is terribad.
    if (window.requestAnimationFrame && this.ctx.lineWidth > 10 && this.isMouseHovering) {
      this.dom.$cursor.css({
        width: this.ctx.lineWidth + 'px',
        height: this.ctx.lineWidth + 'px'
      });
      var transform = DrawingBoard.Utils.tpl("translateX({{x}}px) translateY({{y}}px)", {
        x: this.coords.current.x - this.ctx.lineWidth / 2,
        y: this.coords.current.y - this.ctx.lineWidth / 2
      });
      this.dom.$cursor.css({
        'transform': transform,
        '-webkit-transform': transform,
        '-ms-transform': transform
      });
      this.dom.$cursor.removeClass('drawing-board-utils-hidden');
    } else {
      this.dom.$cursor.addClass('drawing-board-utils-hidden');
    }

    if (this.isDrawing) {
      var currentMid = this._getMidInputCoords(this.coords.current);

      this.ctx.beginPath();
      this.ctx.moveTo(currentMid.x, currentMid.y);
      this.ctx.quadraticCurveTo(this.coords.old.x, this.coords.old.y, this.coords.oldMid.x, this.coords.oldMid.y);
      this.ctx.stroke();
      this.coords.old = this.coords.current;
      this.coords.oldMid = currentMid;
    }

    if (window.requestAnimationFrame) requestAnimationFrame($.proxy(function () {
      this.draw();
    }, this));
  },
  _onInputStart: function _onInputStart(e, coords) {
    this.coords.current = this.coords.old = coords;
    this.coords.oldMid = this._getMidInputCoords(coords);
    this.isDrawing = true;
    if (!window.requestAnimationFrame) this.draw();
    this.ev.trigger('board:startDrawing', {
      e: e,
      coords: coords
    });
    e.stopPropagation();
    e.preventDefault();
  },
  _onInputMove: function _onInputMove(e, coords) {
    this.coords.current = coords;
    this.ev.trigger('board:drawing', {
      e: e,
      coords: coords
    });
    if (!window.requestAnimationFrame) this.draw();
    e.stopPropagation();
    e.preventDefault();
  },
  _onInputStop: function _onInputStop(e, coords) {
    if (this.isDrawing && (!e.touches || e.touches.length === 0)) {
      this.isDrawing = false;
      this.saveWebStorage();
      this.saveHistory();
      this.ev.trigger('board:stopDrawing', {
        e: e,
        coords: coords
      });
      this.ev.trigger('board:userAction');
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _onMouseOver: function _onMouseOver(e, coords) {
    this.isMouseHovering = true;
    this.coords.old = this._getInputCoords(e);
    this.coords.oldMid = this._getMidInputCoords(this.coords.old);
    this.ev.trigger('board:mouseOver', {
      e: e,
      coords: coords
    });
  },
  _onMouseOut: function _onMouseOut(e, coords) {
    this.isMouseHovering = false;
    this.ev.trigger('board:mouseOut', {
      e: e,
      coords: coords
    });
  },
  _getInputCoords: function _getInputCoords(e) {
    e = e.originalEvent ? e.originalEvent : e;
    var rect = this.canvas.getBoundingClientRect(),
        width = this.dom.$canvas.width(),
        height = this.dom.$canvas.height();
    var x, y;

    if (e.touches && e.touches.length == 1) {
      x = e.touches[0].pageX;
      y = e.touches[0].pageY;
    } else {
      x = e.pageX;
      y = e.pageY;
    }

    x = x - this.dom.$canvas.offset().left;
    y = y - this.dom.$canvas.offset().top;
    x *= width / rect.width;
    y *= height / rect.height;
    return {
      x: x,
      y: y
    };
  },
  _getMidInputCoords: function _getMidInputCoords(coords) {
    return {
      x: this.coords.old.x + coords.x >> 1,
      y: this.coords.old.y + coords.y >> 1
    };
  }
};

DrawingBoard.Control = function (drawingBoard, opts) {
  this.board = drawingBoard;
  this.opts = $.extend({}, this.defaults, opts);
  this.$el = $(document.createElement('div')).addClass('drawing-board-control');
  if (this.name) this.$el.addClass('drawing-board-control-' + this.name);
  this.board.ev.bind('board:reset', $.proxy(this.onBoardReset, this));
  this.initialize.apply(this, arguments);
  return this;
};

DrawingBoard.Control.prototype = {
  name: '',
  defaults: {},
  initialize: function initialize() {},
  addToBoard: function addToBoard() {
    this.board.addControl(this);
  },
  onBoardReset: function onBoardReset(opts) {}
}; //extend directly taken from backbone.js

DrawingBoard.Control.extend = function (protoProps, staticProps) {
  var parent = this;
  var child;

  if (protoProps && protoProps.hasOwnProperty('constructor')) {
    child = protoProps.constructor;
  } else {
    child = function child() {
      return parent.apply(this, arguments);
    };
  }

  $.extend(child, parent, staticProps);

  var Surrogate = function Surrogate() {
    this.constructor = child;
  };

  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate();
  if (protoProps) $.extend(child.prototype, protoProps);
  child.__super__ = parent.prototype;
  return child;
};

DrawingBoard.Control.Color = DrawingBoard.Control.extend({
  name: 'colors',
  initialize: function initialize() {
    this.initTemplate();
    var that = this;
    this.$el.on('click', '.drawing-board-control-colors-picker', function (e) {
      var color = $(this).attr('data-color');
      that.board.setColor(color);
      that.$el.find('.drawing-board-control-colors-current').css('background-color', color).attr('data-color', color);
      that.board.ev.trigger('color:changed', color);
      that.$el.find('.drawing-board-control-colors-rainbows').addClass('drawing-board-utils-hidden');
      e.preventDefault();
    });
    this.$el.on('click', '.drawing-board-control-colors-current', function (e) {
      that.$el.find('.drawing-board-control-colors-rainbows').toggleClass('drawing-board-utils-hidden');
      e.preventDefault();
    });
    $('body').on('click', function (e) {
      var $target = $(e.target);
      var $relatedButton = $target.hasClass('drawing-board-control-colors-current') ? $target : $target.closest('.drawing-board-control-colors-current');
      var $myButton = that.$el.find('.drawing-board-control-colors-current');
      var $popup = that.$el.find('.drawing-board-control-colors-rainbows');
      if ((!$relatedButton.length || $relatedButton.get(0) !== $myButton.get(0)) && !$popup.hasClass('drawing-board-utils-hidden')) $popup.addClass('drawing-board-utils-hidden');
    });
  },
  initTemplate: function initTemplate() {
    var tpl = '<div class="drawing-board-control-inner">' + '<div class="drawing-board-control-colors-current" style="background-color: {{color}}" data-color="{{color}}"></div>' + '<div class="drawing-board-control-colors-rainbows">{{rainbows}}</div>' + '</div>';
    var oneColorTpl = '<div class="drawing-board-control-colors-picker" data-color="{{color}}" style="background-color: {{color}}"></div>';
    var rainbows = '';
    $.each([0.75, 0.5, 0.25], $.proxy(function (key, val) {
      var i = 0;
      var additionalColor = null;
      rainbows += '<div class="drawing-board-control-colors-rainbow">';
      if (val == 0.25) additionalColor = this._rgba(0, 0, 0, 1);
      if (val == 0.5) additionalColor = this._rgba(150, 150, 150, 1);
      if (val == 0.75) additionalColor = this._rgba(255, 255, 255, 1);
      rainbows += DrawingBoard.Utils.tpl(oneColorTpl, {
        color: additionalColor.toString()
      });

      while (i <= 330) {
        rainbows += DrawingBoard.Utils.tpl(oneColorTpl, {
          color: this._hsl2Rgba(this._hsl(i - 60, 1, val)).toString()
        });
        i += 30;
      }

      rainbows += '</div>';
    }, this));
    this.$el.append($(DrawingBoard.Utils.tpl(tpl, {
      color: this.board.color,
      rainbows: rainbows
    })));
    this.$el.find('.drawing-board-control-colors-rainbows').addClass('drawing-board-utils-hidden');
  },
  onBoardReset: function onBoardReset(opts) {
    this.board.setColor(this.$el.find('.drawing-board-control-colors-current').attr('data-color'));
  },
  _rgba: function _rgba(r, g, b, a) {
    return {
      r: r,
      g: g,
      b: b,
      a: a,
      toString: function toString() {
        return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
      }
    };
  },
  _hsl: function _hsl(h, s, l) {
    return {
      h: h,
      s: s,
      l: l,
      toString: function toString() {
        return "hsl(" + h + ", " + s * 100 + "%, " + l * 100 + "%)";
      }
    };
  },
  _hex2Rgba: function _hex2Rgba(hex) {
    var num = parseInt(hex.substring(1), 16);
    return this._rgba(num >> 16, num >> 8 & 255, num & 255, 1);
  },
  //conversion function (modified a bit) taken from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
  _hsl2Rgba: function _hsl2Rgba(hsl) {
    var h = hsl.h / 360,
        s = hsl.s,
        l = hsl.l,
        r,
        g,
        b;

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = Math.floor(hue2rgb(p, q, h + 1 / 3) * 255);
      g = Math.floor(hue2rgb(p, q, h) * 255);
      b = Math.floor(hue2rgb(p, q, h - 1 / 3) * 255);
    }

    return this._rgba(r, g, b, 1);
  }
});
DrawingBoard.Control.DrawingMode = DrawingBoard.Control.extend({
  name: 'drawingmode',
  defaults: {
    pencil: true,
    eraser: true,
    filler: true
  },
  initialize: function initialize() {
    this.prevMode = this.board.getMode();
    $.each(["pencil", "eraser", "filler"], $.proxy(function (k, value) {
      if (this.opts[value]) {
        this.$el.append('<button class="drawing-board-control-drawingmode-' + value + '-button" data-mode="' + value + '"></button>');
      }
    }, this));
    this.$el.on('click', 'button[data-mode]', $.proxy(function (e) {
      var value = $(e.currentTarget).attr('data-mode');
      var mode = this.board.getMode();
      if (mode !== value) this.prevMode = mode;
      var newMode = mode === value ? this.prevMode : value;
      this.board.setMode(newMode);
      e.preventDefault();
    }, this));
    this.board.ev.bind('board:mode', $.proxy(function (mode) {
      this.toggleButtons(mode);
    }, this));
    this.toggleButtons(this.board.getMode());
  },
  toggleButtons: function toggleButtons(mode) {
    this.$el.find('button[data-mode]').each(function (k, item) {
      var $item = $(item);
      $item.toggleClass('active', mode === $item.attr('data-mode'));
    });
  }
});
DrawingBoard.Control.Navigation = DrawingBoard.Control.extend({
  name: 'navigation',
  defaults: {
    back: true,
    forward: true,
    reset: true
  },
  initialize: function initialize() {
    var el = '';
    if (this.opts.back) el += '<button class="drawing-board-control-navigation-back">&larr;</button>';
    if (this.opts.forward) el += '<button class="drawing-board-control-navigation-forward">&rarr;</button>';
    if (this.opts.reset) el += '<button class="drawing-board-control-navigation-reset">&times;</button>';
    this.$el.append(el);

    if (this.opts.back) {
      var $back = this.$el.find('.drawing-board-control-navigation-back');
      this.board.ev.bind('historyNavigation', $.proxy(this.updateBack, this, $back));
      this.$el.on('click', '.drawing-board-control-navigation-back', $.proxy(function (e) {
        this.board.goBackInHistory();
        e.preventDefault();
      }, this));
      this.updateBack($back);
    }

    if (this.opts.forward) {
      var $forward = this.$el.find('.drawing-board-control-navigation-forward');
      this.board.ev.bind('historyNavigation', $.proxy(this.updateForward, this, $forward));
      this.$el.on('click', '.drawing-board-control-navigation-forward', $.proxy(function (e) {
        this.board.goForthInHistory();
        e.preventDefault();
      }, this));
      this.updateForward($forward);
    }

    if (this.opts.reset) {
      this.$el.on('click', '.drawing-board-control-navigation-reset', $.proxy(function (e) {
        this.board.reset({
          background: true
        });
        e.preventDefault();
      }, this));
    }
  },
  updateBack: function updateBack($back) {
    if (this.board.history.canUndo()) {
      $back.removeAttr('disabled');
    } else {
      $back.attr('disabled', 'disabled');
    }
  },
  updateForward: function updateForward($forward) {
    if (this.board.history.canRedo()) {
      $forward.removeAttr('disabled');
    } else {
      $forward.attr('disabled', 'disabled');
    }
  }
});
DrawingBoard.Control.Size = DrawingBoard.Control.extend({
  name: 'size',
  defaults: {
    type: "auto",
    dropdownValues: [1, 3, 6, 10, 20, 30, 40, 50],
    min: 1,
    max: 50
  },
  types: ['dropdown', 'range'],
  initialize: function initialize() {
    if (this.opts.type == "auto") this.opts.type = this._iHasRangeInput() ? 'range' : 'dropdown';
    var tpl = $.inArray(this.opts.type, this.types) > -1 ? this['_' + this.opts.type + 'Template']() : false;
    if (!tpl) return false;
    this.val = this.board.opts.size;
    this.$el.append($(tpl));
    this.$el.attr('data-drawing-board-type', this.opts.type);
    this.updateView();
    var that = this;

    if (this.opts.type == "range") {
      this.$el.on('change', '.drawing-board-control-size-range-input', function (e) {
        that.val = $(this).val();
        that.updateView();
        that.board.ev.trigger('size:changed', that.val);
        e.preventDefault();
      });
    }

    if (this.opts.type == "dropdown") {
      this.$el.on('click', '.drawing-board-control-size-dropdown-current', $.proxy(function (e) {
        this.$el.find('.drawing-board-control-size-dropdown').toggleClass('drawing-board-utils-hidden');
      }, this));
      this.$el.on('click', '[data-size]', function (e) {
        that.val = parseInt($(this).attr('data-size'), 0);
        that.updateView();
        that.board.ev.trigger('size:changed', that.val);
        e.preventDefault();
      });
    }
  },
  _rangeTemplate: function _rangeTemplate() {
    var tpl = '<div class="drawing-board-control-inner" title="{{size}}">' + '<input type="range" min="{{min}}" max="{{max}}" value="{{size}}" step="1" class="drawing-board-control-size-range-input">' + '<span class="drawing-board-control-size-range-current"></span>' + '</div>';
    return DrawingBoard.Utils.tpl(tpl, {
      min: this.opts.min,
      max: this.opts.max,
      size: this.board.opts.size
    });
  },
  _dropdownTemplate: function _dropdownTemplate() {
    var tpl = '<div class="drawing-board-control-inner" title="{{size}}">' + '<div class="drawing-board-control-size-dropdown-current"><span></span></div>' + '<ul class="drawing-board-control-size-dropdown">';
    $.each(this.opts.dropdownValues, function (i, size) {
      tpl += DrawingBoard.Utils.tpl('<li data-size="{{size}}"><span style="width: {{size}}px; height: {{size}}px; border-radius: {{size}}px;"></span></li>', {
        size: size
      });
    });
    tpl += '</ul></div>';
    return tpl;
  },
  onBoardReset: function onBoardReset(opts) {
    this.updateView();
  },
  updateView: function updateView() {
    var val = this.val;
    this.board.ctx.lineWidth = val;
    this.$el.find('.drawing-board-control-size-range-current, .drawing-board-control-size-dropdown-current span').css({
      width: val + 'px',
      height: val + 'px',
      borderRadius: val + 'px',
      marginLeft: -1 * val / 2 + 'px',
      marginTop: -1 * val / 2 + 'px'
    });
    this.$el.find('.drawing-board-control-inner').attr('title', val);

    if (this.opts.type == 'dropdown') {
      var closest = null;
      $.each(this.opts.dropdownValues, function (i, size) {
        if (closest === null || Math.abs(size - val) < Math.abs(closest - val)) closest = size;
      });
      this.$el.find('.drawing-board-control-size-dropdown').addClass('drawing-board-utils-hidden');
    }
  },
  _iHasRangeInput: function _iHasRangeInput() {
    var inputElem = document.createElement('input'),
        smile = ':)',
        docElement = document.documentElement,
        inputElemType = 'range',
        available;
    inputElem.setAttribute('type', inputElemType);
    available = inputElem.type !== 'text';
    inputElem.value = smile;
    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

    if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {
      docElement.appendChild(inputElem);
      defaultView = document.defaultView;
      available = defaultView.getComputedStyle && defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' && inputElem.offsetHeight !== 0;
      docElement.removeChild(inputElem);
    }

    return !!available;
  }
});
DrawingBoard.Control.Download = DrawingBoard.Control.extend({
  name: 'download',
  initialize: function initialize() {
    this.$el.append('<button class="drawing-board-control-download-button"></button>');
    this.$el.on('click', '.drawing-board-control-download-button', $.proxy(function (e) {
      this.board.downloadImg();
      e.preventDefault();
    }, this));
  }
});
// EXTERNAL MODULE: ./lib/drawingboard/index.css
var drawingboard = __webpack_require__(1);

// CONCATENATED MODULE: ./index.js
/**
 * 2019/4/2
 * drawingboard.js
 * author: sfl
 */



(function (w, d) {
  var Z_INDEX = 0;
  var BOARD_ARR = [];

  var Board = function Board(o) {
    this.options = Object.assign({}, o);
    this.controls = ["Color", {
      Size: {
        type: "dropdown"
      }
    }, 'Navigation', {
      DrawingMode: {
        filler: false
      }
    }];
    this.init();
  };

  Board.prototype = {
    init: function init() {
      Z_INDEX = this.options.zIndex;
      this.createBoard();
    },
    createBoard: function createBoard() {
      var _this = this;

      var wrapDom = this.getWrapDom();
      wrapDom.style.position = "relative";
      var item = d.createElement('div');
      item.setAttribute("id", "board-" + Z_INDEX);
      item.style.position = "absolute";
      item.style.width = "100%";
      item.style.height = "100%";
      item.style.zIndex = Z_INDEX;
      wrapDom.appendChild(item);
      var board = new window.DrawingBoard.Board(item.id, {
        background: false,
        color: _this.options.color,
        size: _this.options.size,
        controls: _this.controls,
        eraserColor: 'background',
        webStorage: 'local'
      });
      board.addControl('Download');
      BOARD_ARR.push({
        "boardItem": board,
        "zIndex": Z_INDEX
      });
    },
    getWrapDom: function getWrapDom() {
      var dom = null;

      switch (this.options.el[0]) {
        case "#":
          dom = d.getElementById(this.options.el.substr(1));
          break;

        case ".":
          dom = d.getElementsByClassName(this.options.el.substr(1))[0];
          break;

        default:
          dom = d.getElementsByTagName(this.options.el)[0];
          break;
      }

      return dom;
    },
    getZindex: function getZindex() {
      return Z_INDEX;
    },
    getBoardInfo: function getBoardInfo() {
      return BOARD_ARR;
    }
  };
  w.Board = Board;
})(window, document);

/***/ })
/******/ ]);